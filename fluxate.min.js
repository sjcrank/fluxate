var fluxate={createAction:function(n){n=n||{};var e=n.preExecHandlers?n.preExecHandlers:[];return{name:n.name?n.name.toString():"unnamed",exec:function(){for(var t=0;t<e.length;t++){var r=e[t].apply(this,arguments);if(!r)return}n.exec&&n.exec.apply(this,arguments)}}},createStore:function(){var n=[],e=!1,t=function(){e=!0,n.forEach(function(n){n.fn.apply(n.context)}),e=!1};return{onChange:function(t,r){if(e)throw"Adding a change listener while notifying";n.push({fn:t,context:r||this})},offChange:function(t){if(e)throw"Removing a change listener while notifying";for(var r=0;r<n.length;r++)if(n[r].fn===t){n.splice(r,1);break}},addProp:function(n){if(n=n||{},!n.name)throw"Property name was not supplied";var r=n.preCommitHandlers?n.preCommitHandlers:[],i=n.initValue?n.initValue:null;this[n.name]=function(){if(0===arguments.length)return i;if(e)throw"Changing a property while notifying";for(var n=0;n<r.length;n++){var o=r[n].call(this,i,arguments[0]);if(!o)return}i=arguments[0],t()}}}},createStoreWatchMixin:function(){var n=Array.prototype.slice.call(arguments),e=function(){this.isMounted()&&this.setState(this.getStateFromStore())};return{componentDidMount:function(){for(var t=0;t<n.length;t++)n[t].onChange(e,this)},componentWillUnmount:function(){for(var t=0;t<n.length;t++)n[t].offChange(e,this)},getInitialState:function(){return this.getStateFromStore()}}}};"undefined"!=typeof module&&null!==module&&module.exports?module.exports=fluxate:"function"==typeof define&&define.amd&&define(function(){return fluxate});
//# sourceMappingURL=fluxate.js.map